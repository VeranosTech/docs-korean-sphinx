
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Miscellaneous markup &#8212; Sphinx 1.7+ documentation</title>
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.7+',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Sphinx 1.7+ documentation에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
  <body>
<div class="pageheader">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="../install.html">Get it</a></li>
    <li><a href="../contents.html">Docs</a></li>
    <li><a href="../develop.html">Extend/Develop</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/sphinxheader.png" alt="SPHINX" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li><a href="../index.html">Sphinx home</a>&#160;|</li>
        <li><a href="../contents.html">Documentation</a> &#187;</li>
 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">Miscellaneous markup</a><ul>
<li><a class="reference internal" href="#file-wide-metadata">File-wide metadata</a></li>
<li><a class="reference internal" href="#meta-information-markup">Meta-information markup</a></li>
<li><a class="reference internal" href="#index-generating-markup">Index-generating markup</a></li>
<li><a class="reference internal" href="#including-content-based-on-tags">Including content based on tags</a></li>
<li><a class="reference internal" href="#tables">Tables</a></li>
<li><a class="reference internal" href="#math">Math</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>현재 문서</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/markup/misc_ko.rst.txt"
            rel="nofollow">소스 코드를 보려면</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>빠른 검색</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="바로 가기" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="miscellaneous-markup">
<h1>Miscellaneous markup<a class="headerlink" href="#miscellaneous-markup" title="제목 주소">¶</a></h1>
<div class="section" id="file-wide-metadata">
<span id="metadata"></span><h2>File-wide metadata<a class="headerlink" href="#file-wide-metadata" title="제목 주소">¶</a></h2>
<p>reST는 &quot;field list&quot;라는 개념을 가지고 있다. 이들은 다음과 같이 주어지는 field들의 시퀀스이다:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span><span class="nc">:fieldname:</span> <span class="nf">Field content</span>
</pre></div>
</div>
<p>파일 상단 근처의 field list는 &quot;docinfo&quot;로 docutils에 의해 파싱된다, 일반적으로 저자, 발행일,
기타 metadata를 기록하는 데 사용된다. <em>Sphinx</em> 에서는 모든 markup 앞에 오는 field list는
문서 metadata로 docinfo에서 Sphinx environment로 이동되며 output에 표시되지 않는다.
문서 제목 다음에 나타나는 field list는 정상적으로 docinfo에 포함되어 output에 표시된다.</p>
<p>현재 인식되는 metadata field들은 다음과 같다:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tocdepth</span></code></dt>
<dd><p class="first">이 파일의 목차에서의 최대 깊이.</p>
<div class="last versionadded">
<p><span class="versionmodified">버전 0.4에 추가.</span></p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">nocomments</span></code></dt>
<dd>만약 설정된다면, 웹 애플리케이션에서 이 소스 파일에서 생성된 페이지에 comment form을 표시하지
않는다.</dd>
<dt><code class="docutils literal"><span class="pre">orphan</span></code></dt>
<dd><p class="first">만약 설정된다면, 이 파일이 toctree에 포함되지 않았다는 경고가 발생하지 않는다.</p>
<div class="last versionadded">
<p><span class="versionmodified">버전 1.0에 추가.</span></p>
</div>
</dd>
</dl>
</div>
<div class="section" id="meta-information-markup">
<h2>Meta-information markup<a class="headerlink" href="#meta-information-markup" title="제목 주소">¶</a></h2>
<dl class="directive">
<dt id="directive-sectionauthor">
<code class="descname">.. sectionauthor::</code><code class="descclassname"> name &lt;email&gt;</code><a class="headerlink" href="#directive-sectionauthor" title="정의 주소">¶</a></dt>
<dd><p>현재 section의 작성자를 나타낸다. 프레젠테이션과 이메일 주소에 사용 할 수 있도록 작성자
이름이 argument에 포함되어야 한다. 주소의 도메인 이름 부분은 소문자이여야 한다. 예:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">sectionauthor</span><span class="p">::</span> Guido van Rossum &lt;guido@python.org&gt;
</pre></div>
</div>
<p>기본적으로 이 markup은 output에 반영되지 않지만 기여도를 기록하는데는 요긴하다. 하지만
설정값을 <a class="reference internal" href="../config.html#confval-show_authors"><code class="xref std std-confval docutils literal"><span class="pre">show_authors</span></code></a> 에서 <code class="docutils literal"><span class="pre">True</span></code> 로 해놓으면 output에 표시가 가능하다.</p>
</dd></dl>

<dl class="directive">
<dt id="directive-codeauthor">
<code class="descname">.. codeauthor::</code><code class="descclassname"> name &lt;email&gt;</code><a class="headerlink" href="#directive-codeauthor" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#directive-sectionauthor" title="sectionauthor directive"><code class="xref rst rst-dir docutils literal"><span class="pre">sectionauthor</span></code></a> 가 문서의 저자(들)을 지정하듯이, <a class="reference internal" href="#directive-codeauthor" title="codeauthor directive"><code class="xref rst rst-dir docutils literal"><span class="pre">codeauthor</span></code></a>
directive는 주어진 코드의 작성자 이름을 지정하며, 여러번 사용 가능하다. 마찬가지로
<a class="reference internal" href="../config.html#confval-show_authors"><code class="xref std std-confval docutils literal"><span class="pre">show_authors</span></code></a> 설정값이 <code class="docutils literal"><span class="pre">True</span></code> 인 경우에만 output을 생성한다.</p>
</dd></dl>

</div>
<div class="section" id="index-generating-markup">
<h2>Index-generating markup<a class="headerlink" href="#index-generating-markup" title="제목 주소">¶</a></h2>
<p>Sphinx는 <a class="reference internal" href="../domains_ko.html#domains"><span class="std std-ref">Sphinx Domains</span></a> 에서 설명 된 것처럼 모든 객체의 설명(function, class,
attribute)으로부터 index entry를 자동으로 생성한다.</p>
<p>그러나 index를 보다 포괄적으로 만들고, 정보가 주로 language refrence와 같이 정보 단위에
포함되지 않는 문서에서 index entry를 사용 할 수 있도록 해주는 markup도 있다.</p>
<dl class="directive">
<dt id="directive-index">
<code class="descname">.. index::</code><code class="descclassname"> &lt;entries&gt;</code><a class="headerlink" href="#directive-index" title="정의 주소">¶</a></dt>
<dd><p>이 directive는 하나 이상의 index entry가 들어간다. 각 entry는 type과 value로 구성되며,
이 둘은 콜론으로 구분짓는다.</p>
<p>예:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">index</span><span class="p">::</span>
   single: execution; context
   module: __main__
   module: sys
   triple: module; search; path

<span class="gh">The execution context</span>
<span class="gh">---------------------</span>

<span class="cp">...</span>
</pre></div>
</div>
<p>위의 directive는 5개의 entry를 포함하며, 생성 된 index의 entry로 변환되어 index 명령문의
정확한 위치(오프라인 매체의 경우 해당 페이지의 번호)로 연결된다.</p>
<p>Index directive는 소스의 해당 위치에서 cross-reference 대상을 생성하기 때문에 위의
예제에서와 같이 참조하는 것 <em>앞에</em> 넣는 것이 좋다.</p>
<p>가능한 entry의 type은 다음과 같다.</p>
<dl class="docutils">
<dt>single</dt>
<dd>단일 index entry를 생성한다. 세미콜론을 사용함으로 subentry를 생성하는 것도 가능하다.
(이 표기법은 아래의 항목들에도 사용된다)</dd>
<dt>pair</dt>
<dd><code class="docutils literal"><span class="pre">pair:</span> <span class="pre">loop;</span> <span class="pre">statement</span></code> 는 <code class="docutils literal"><span class="pre">loop;</span> <span class="pre">statement</span></code> 와 <code class="docutils literal"><span class="pre">statement;</span> <span class="pre">loop</span></code>
두개의 index entry를 만들기 위한 축약 표현이다.</dd>
<dt>triple</dt>
<dd>마찬가지로, <code class="docutils literal"><span class="pre">triple:</span> <span class="pre">module;</span> <span class="pre">search;</span> <span class="pre">path</span></code> 는 <code class="docutils literal"><span class="pre">module;</span> <span class="pre">search</span> <span class="pre">path</span></code>,
<code class="docutils literal"><span class="pre">search;</span> <span class="pre">path</span> <span class="pre">module</span></code>, <code class="docutils literal"><span class="pre">path;</span> <span class="pre">module</span> <span class="pre">search</span></code> 세개의 index entry를
만든다.</dd>
<dt>see</dt>
<dd><code class="docutils literal"><span class="pre">see:</span> <span class="pre">entry;</span> <span class="pre">other</span></code> 는 <code class="docutils literal"><span class="pre">entry</span></code> 에서 <code class="docutils literal"><span class="pre">other</span></code> 를 가리키는 index entry를
만든다.</dd>
<dt>seealso</dt>
<dd><code class="docutils literal"><span class="pre">see</span></code> 와 같지만 &quot;see&quot; 대신에 &quot;see also&quot; 를 삽입한다.</dd>
<dt>module, keyword, operator, object, exception, statement, builtin</dt>
<dd>이것들은 모두 두개의 index entry를 만든다. 예를들어, <code class="docutils literal"><span class="pre">module:</span> <span class="pre">hashlib</span></code> 는
<code class="docutils literal"><span class="pre">module;</span> <span class="pre">hashlib</span></code> 와 <code class="docutils literal"><span class="pre">hashlib;</span> <span class="pre">module</span></code> 을 만든다. 다만 이것들은
Python에만 한정되어 있으며 deprecate 되었다.</dd>
</dl>
<p>앞에 느낌표를 붙여서 &quot;main&quot; index entry를 표시할 수 있다. &quot;main&quot; 항목에 대한 reference는
생성 된 index에서 강조된다. 예를 들어 두 페이지에 다음과 같은게 있고:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">index</span><span class="p">::</span> Python
</pre></div>
</div>
<p>그리고 다른 한 페이지에는 다음과 같은게 있다면:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">index</span><span class="p">::</span> ! Python
</pre></div>
</div>
<p>세개의 backlink들 중에서 제일 나중의 것만 강조된다.</p>
<p>만약 index directive가 &quot;single&quot; entry만 포함한다면 다음과 같은 축약형을 쓸 수 있다:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span><span class="p">..</span> <span class="ow">index</span><span class="p">::</span> BNF, grammar, syntax, notation
</pre></div>
</div>
<p>이렇게 하면 네 개의 index entry가 생성된다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.1으로 변경: </span>Added <code class="docutils literal"><span class="pre">see</span></code> and <code class="docutils literal"><span class="pre">seealso</span></code> types, as well as marking main entries.</p>
</div>
</dd></dl>

<dl class="role">
<dt id="role-index">
<code class="descname">:index:</code><a class="headerlink" href="#role-index" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#directive-index" title="index directive"><code class="xref rst rst-dir docutils literal"><span class="pre">index</span></code></a> directive는 다음 문단의 시작 부분에 연결되는 block 레벨의 markup이다.
링크 대상이 사용되는 곳에서 직접 링크 대상을 설정하는 대응되는 role도 있다.</p>
<p>Role의 내용은 간단한 구절일 수 있으며, 이는 텍스트로 유지되고 index entry로 사용 가능하다.
또한 cross-reference의 명시된 대상들과 같은 스타일로 텍스트와 index entry의 조합일 수도
있다. 이 경우, &quot;target&quot; 부분은 위의 directive에서 설명한대로 full entry가 될 수도
있다. 예를 들면:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>This is a normal reST <span class="na">:index:</span><span class="nv">`paragraph`</span> that contains several
<span class="nc">:index:`index entries &lt;pair:</span> <span class="nf">index; entry&gt;`.</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 1.1에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="including-content-based-on-tags">
<span id="tags"></span><h2>Including content based on tags<a class="headerlink" href="#including-content-based-on-tags" title="제목 주소">¶</a></h2>
<dl class="directive">
<dt id="directive-only">
<code class="descname">.. only::</code><code class="descclassname"> &lt;expression&gt;</code><a class="headerlink" href="#directive-only" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>expression</em> 이 true인 경우에만 directive의 내용을 포함한다. 다음과 같이
expression은 태그로 구성되어야 한다.</p>
<blockquote>
<div></div></blockquote>
<p>정의되지 않은 태그는 false, 정의 된 태그(<code class="docutils literal"><span class="pre">-t</span></code> command-line 옵션을 통해 또는
<code class="file docutils literal"><span class="pre">conf.py</span></code> 안에서 설정, <a class="reference internal" href="../config.html#conf-tags"><span class="std std-ref">here</span></a> 참조)는 true로 간주된다.
<code class="docutils literal"><span class="pre">html</span> <span class="pre">and</span> <span class="pre">(latex</span> <span class="pre">or</span> <span class="pre">draft)</span></code> 와 같이 괄호를 사용하는 boolean expression도 지원된다.</p>
<p>현재 builder(<code class="docutils literal"><span class="pre">html</span></code>, <code class="docutils literal"><span class="pre">latex</span></code> 또는 <code class="docutils literal"><span class="pre">text</span></code>)의 <em>format</em> 과 <em>name</em> 은 항상
태그 <a class="footnote-reference" href="#id2" id="id1">[1]</a> 로 설정된다. 여기에선, format과 name을 구별하기 위해서 접두로 <code class="docutils literal"><span class="pre">format_</span></code> 과
<code class="docutils literal"><span class="pre">builder_</span></code> 가 추가된다. 예를 들어, epub builder는 <code class="docutils literal"><span class="pre">html</span></code>, <code class="docutils literal"><span class="pre">epub</span></code>,
<code class="docutils literal"><span class="pre">format_html</span></code>, <code class="docutils literal"><span class="pre">builder_epub</span></code> 태그를 정의한다.</p>
<p>이 표준 태그들은 설정 파일을 읽은 <em>후에</em> 지정되므로 설정 파일에서는 사용 할 수 없다.</p>
<p><a class="reference external" href="https://docs.python.org/2/reference/lexical_analysis.html#identifiers">Identifiers and keywords</a>
에서 설정된 표준 Python identifier syntax를 모든 태그는 따라야 한다. 즉, 태그
expression은 Python variable의 syntax를 따르는 태그로만 구성 될 수 있다.
ASCII에서는 <code class="docutils literal"><span class="pre">A</span></code> 부터 <code class="docutils literal"><span class="pre">Z</span></code> 까지의 대문자와 소문자, 밑줄 <code class="docutils literal"><span class="pre">_</span></code>, <code class="docutils literal"><span class="pre">0</span></code> 부터 <code class="docutils literal"><span class="pre">9</span></code>
까지의 숫자(첫번째 문자 제외)로 구성된다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 0.6에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.2으로 변경: </span>Added the name of the builder and the prefixes.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last">이 directive는 문서의 내용만 제어하도록 설계되었다. Section, label 등은 제어 할 수
없다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="tables">
<h2>Tables<a class="headerlink" href="#tables" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="../rest_ko.html#rst-tables"><span class="std std-ref">reStructuredText tables</span></a> 를 사용하면 된다. 즉, 다음 중 하나를
사용한다.</p>
<ul class="simple">
<li>grid table syntax (<a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#grid-tables">ref</a>),</li>
<li>simple table syntax (<a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#simple-tables">ref</a>),</li>
<li><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#csv-table">csv-table</a> syntax,</li>
<li><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#list-table">list-table</a> syntax.</li>
</ul>
<p><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#table">table</a> directive는 <em>grid</em> 와 <em>simple</em> syntax의 wrapper 역할을 한다.</p>
<p>위의 예시들은 HTML 출력에서는 잘 작동하지만, LaTeX에서 테이블을 사용할 때에는 몇 가지 문제가 생긴다.
예를 들면 column width를 자동으로 올바르게 판별하질 못한다. 이러한 이유로 다음 directive가
존재한다.</p>
<dl class="directive">
<dt id="directive-tabularcolumns">
<code class="descname">.. tabularcolumns::</code><code class="descclassname"> column spec</code><a class="headerlink" href="#directive-tabularcolumns" title="정의 주소">¶</a></dt>
<dd><p>이 directive는 소스 파일에서 나타나는 다음 테이블의 &quot;column spec&quot; 설정한다. 여기서 spec은
Sphinx가 테이블 변환에 사용하는 LaTeX <code class="docutils literal"><span class="pre">tabulary</span></code> 패키지의 환경에서 사용하는 두번째
argument이다. 다음과 같은 값을 가질 수 있다:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>|l|l|l|
</pre></div>
</div>
<p>이것은 left-adjuest된 세 개의 연속적인 column을 의미한다. 긴 텍스트가 있어 자동으로
분할되어야 하는 경우, 표준인 <code class="docutils literal"><span class="pre">p{width}</span></code> 를 사용하거나 tabulary의 자동
specifier를 사용한다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">L</span></code></td>
<td>flush left column with automatic width</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">R</span></code></td>
<td>flush right column with automatic width</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">C</span></code></td>
<td>centered column with automatic width</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">J</span></code></td>
<td>justified column with automatic width</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">LRCJ</span></code> column의 자동 너비는 <code class="docutils literal"><span class="pre">tabulary</span></code> 에 의해 셀의 자연스러운 &quot;가로&quot; 너비로 렌더링
되도록 설정된다.</p>
<p>기본적으로 Sphinx는 테이블 레이아웃에서 모든 column에 <code class="docutils literal"><span class="pre">J</span></code> 를 사용한다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 0.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.6으로 변경: </span>Merged cells may now contain multiple paragraphs and are much better
handled, thanks to custom Sphinx LaTeX macros. This novel situation
motivated the switch to <code class="docutils literal"><span class="pre">J</span></code> specifier and not <code class="docutils literal"><span class="pre">L</span></code> by default.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">힌트</p>
<p>Sphinx는 실제로 <code class="docutils literal"><span class="pre">T</span></code> specifier 가 들어간 <code class="docutils literal"><span class="pre">\newcolumntype{T}{J}</span></code> 를 사용한다.
이전 default로 되돌리려면 LaTeX preamble에 <code class="docutils literal"><span class="pre">\newcolumntype{T}{L}</span></code> 를 넣으면
된다. (<a class="reference internal" href="../config.html#confval-latex_elements"><code class="xref std std-confval docutils literal"><span class="pre">latex_elements</span></code></a> 참조)</p>
<p>Tabulary에서 자주 발생하는 문제로는, 내용이 거의 없는 column들이 &quot;압축&quot; 된다는 것이다.
최소 column width는 <code class="docutils literal"><span class="pre">\tymin</span></code> 이라고 불리는 tabulary의 parameter이다. 이는
LaTeX preamble에서 <code class="docutils literal"><span class="pre">\setlength{\tymin}{40pt}</span></code> 식으로 사용하는 걸로 글로벌
설정이 가능하다.</p>
<p class="last">그렇지 않으면, 그 column에 <a class="reference internal" href="#directive-tabularcolumns" title="tabularcolumns directive"><code class="xref rst rst-dir docutils literal"><span class="pre">tabularcolumns</span></code></a> directive에 <code class="docutils literal"><span class="pre">p{40pt}</span></code>
식으로 직접 명시하면 된다. <code class="docutils literal"><span class="pre">l</span></code> specifier를 사용 할 수도 있지만, 만약 병합 된 cell이
column과 겹치게 된다면, column width를 설정하는 작업이 더 어려워진다.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p>30개 이상의 행을 가진 테이블은 페이지 분할을 위해서 <code class="docutils literal"><span class="pre">tabulary</span></code> 를 사용하지 않고
<code class="docutils literal"><span class="pre">longtable</span></code> 을 이용해서 렌더링 된다. 이 경우에는 <code class="docutils literal"><span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">R</span></code>, 등의 specifier는
작동하지 않는다.</p>
<p>객체 설명, 블록 인용, 목록 등의 list와 같은 요소를 포함하는 테이블은 <code class="docutils literal"><span class="pre">tabulary</span></code> 로
바로 사용 할 수 없다. 따라서 이 경우에는 <code class="docutils literal"><span class="pre">tabularcolumns</span></code> directive를 제공하지
않는다면 표준 LaTeX <code class="docutils literal"><span class="pre">tabular</span></code> (또는 <code class="docutils literal"><span class="pre">longtable</span></code>) 환경으로 설정 되어 버린다.
만약 <code class="docutils literal"><span class="pre">tabularcolumns</span></code> directive를 사용한다면, 테이블은 <code class="docutils literal"><span class="pre">tabulary</span></code> 로 설정
되지만, 이 경우, 이러한 list와 같은 요소를 포함한 column에는 <code class="docutils literal"><span class="pre">p{width}</span></code>
construct(또는 아래에 기술된 Sphinx의 <code class="docutils literal"><span class="pre">\X</span></code> 와 <code class="docutils literal"><span class="pre">\Y</span></code> specifier)를 사용해야 한다.</p>
<p class="last">Literal block은 <code class="docutils literal"><span class="pre">tabulary</span></code> 로는 사용 할 수 없다. 따라서 literal block을 포함하는
테이블은 항상 <code class="docutils literal"><span class="pre">tabular</span></code> 로 설정되어야 한다. Literal block에 사용되는 verbatim
environment는 <code class="docutils literal"><span class="pre">p{width}``(및</span> <span class="pre">``\X</span></code> 또는 <code class="docutils literal"><span class="pre">\Y</span></code>)가 설정된 column에서만
작동하므로 Sphinx는 literal block이 포함 된 테이블에 대해 이러한 column spec을
생성한다.</p>
</div>
<p>Sphinx 1.5부터는 <code class="docutils literal"><span class="pre">\X{a}{b}</span></code> specifier가 사용된다. (specifier에 <em>백슬래시</em> 가
있다는 점에 주목) 이것은 <code class="docutils literal"><span class="pre">p{width}</span></code> 와 비슷하지만 현재 행의 너비의 비율 <code class="docutils literal"><span class="pre">a/b</span></code> 로
설정된다. 이는 <a class="reference internal" href="#directive-tabularcolumns" title="tabularcolumns directive"><code class="xref rst rst-dir docutils literal"><span class="pre">tabularcolumns</span></code></a> 에서도 사용 가능하다. 심지어 일부 LaTeX 매크로가
<code class="docutils literal"><span class="pre">\X</span></code> 라고 정의되었어도 문제가 되지 않는다.</p>
<p><code class="docutils literal"><span class="pre">b</span></code> 는 총 column 수일 <em>필요는 없으며</em>, <code class="docutils literal"><span class="pre">\X</span></code> specifier의 분수 합계가 1이 될
<em>필요도 없다</em>. 예를 들어 <code class="docutils literal"><span class="pre">|\X{2}{5}|\X{1}{5}|\X{1}{5}|</span></code> 는 허용되는 표현이며,
이 때, 테이블은 line width의 80%를 차지하게 된다.</p>
<p>이것은 <a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#table">table</a> directive의 <code class="docutils literal"><span class="pre">:widths:</span></code> 옵션에 의해 사용된다.</p>
<p>Sphinx 1.6 이후부터는 <code class="docutils literal"><span class="pre">\Y{0.15}</span></code> 와 같이 소수 표현을 허용하는 <code class="docutils literal"><span class="pre">\Y{f}</span></code> specifier도
존재한다. 이것은 <code class="docutils literal"><span class="pre">\X{3}{20}</span></code> 와 똑같은 효과를 가진다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 1.6으로 변경: </span>Merged cells from complex grid tables (either multi-row, multi-column, or
both) now allow blockquotes, lists, literal blocks, ... as do regular cells.</p>
<p>Sphinx's merged cells interact well with <code class="docutils literal"><span class="pre">p{width}</span></code>, <code class="docutils literal"><span class="pre">\X{a}{b}</span></code>, <code class="docutils literal"><span class="pre">Y{f}</span></code>
and tabulary's columns.</p>
</div>
</dd></dl>

</div>
<div class="section" id="math">
<h2>Math<a class="headerlink" href="#math" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="../ext/math.html#math-support"><span class="std std-ref">Math support in Sphinx</span></a> 참조.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">대부분의 builder는 name과 format이 동일하다. 현재에는 html builder에서 파생된
builder만 builder format과 builder name을 구별한다.</p>
<p class="last">현재 builder의 태그는 <code class="docutils literal"><span class="pre">conf.py</span></code> 에서 사용할 수 없으며, builder가 초기화 된
후에만 사용 할 수 있다.</p>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li><a href="../index.html">Sphinx home</a>&#160;|</li>
        <li><a href="../contents.html">Documentation</a> &#187;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2017, Georg Brandl and the Sphinx team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7+.
    </div>
  </body>
</html>